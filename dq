#!/usr/bin/env bash
# This script was generated by bashly 0.8.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dq_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq - A wrapper around Docker and jq that allows you to filter running Docker containers.\n"
    echo

  else
    printf "dq - A wrapper around Docker and jq that allows you to filter running Docker containers.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq [command]\n"
  printf "  dq [command] --help | -h\n"
  printf "  dq --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  filter               Run a free-form jq filter against your local running Docker containers."
  echo "  older-than           Return a list of containers older than the given relative time. "
  echo "  newer-than           Return a list of containers older than the given relative time."
  echo "  find-by-ip-address   Return a list of containers assigned the given IP address."
  echo "  names-only           Returns a list of names associated with all running containers."
  echo "  ip-addresses-only    Returns a list of IP addresses associated with the specified network."
  echo "  env                  Returns a block of sourceable environmental variables associated with the specified container."
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dq_filter_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq filter - Run a free-form jq filter against your local running Docker containers.\n"
    echo

  else
    printf "dq filter - Run a free-form jq filter against your local running Docker containers.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq filter [FILTER] [options]\n"
  printf "  dq filter --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  FILTER"
    printf "    The filter to apply to docker inspect's JSON output.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq filter '. | length'\n"
    printf "  dq filter '.[].Name[1:]'\n"
    echo

  fi
}

# :command.usage
dq_older_than_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq older-than\n"
    echo

    printf "  Return a list of containers older than the given relative time.\n"
    echo

  else
    printf "dq older-than - Return a list of containers older than the given relative time.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq older-than [options] [DATE STRING...]\n"
  printf "  dq older-than --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --only-return RETURN"
    printf "    Return the supported values instead of matching JSON.\n"
    printf "    Allowed: ips, names, ids, json\n"
    printf "    Default: json\n"
    echo

    # :flag.usage
    echo "  --network NETWORK"
    printf "    Return IP addresses associated with the specified Docker network. This only\n    works when returning ips with the --only-return flag.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    echo "  DATE STRING..."
    printf "    A GNU date-compatible relative time string.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq older-than 4 months --only-return ips --network pebkac\n"
    printf "  dq older-than 34 seconds\n"
    printf "  dq older-than 2 fortnights --only-return ids\n"
    echo

  fi
}

# :command.usage
dq_newer_than_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq newer-than\n"
    echo

    printf "  Return a list of containers older than the given relative time.\n"
    echo

  else
    printf "dq newer-than - Return a list of containers older than the given relative time.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq newer-than [options] [DATE STRING...]\n"
  printf "  dq newer-than --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --only-return RETURN"
    printf "    Return the supported values instead of matching JSON.\n"
    printf "    Allowed: ips, names, ids, json\n"
    printf "    Default: json\n"
    echo

    # :flag.usage
    echo "  --network, -n NETWORK"
    printf "    Return IP addresses associated with the specified Docker network. This only\n    works when returning ips with the --only-return flag.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    echo "  DATE STRING..."
    printf "    A GNU date-compatible relative time string.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq newer-than 4 months --only-return ips --network pebkac\n"
    printf "  dq newer-than 34 seconds\n"
    printf "  dq newer-than 2 fortnights --only-return ids\n"
    echo

  fi
}

# :command.usage
dq_find_by_ip_address_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq find-by-ip-address - Return a list of containers assigned the given IP address.\n"
    echo

  else
    printf "dq find-by-ip-address - Return a list of containers assigned the given IP address.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq find-by-ip-address IP [options]\n"
  printf "  dq find-by-ip-address --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --only-return RETURN"
    printf "    Return the supported values instead of matching JSON.\n"
    printf "    Allowed: names, ids, json\n"
    printf "    Default: json\n"
    echo

    # :flag.usage
    echo "  --network NETWORK"
    printf "    Return IP addresses associated with the specified Docker network.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  IP"
    printf "    The IP address associated with the desired container.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq find-by-ip-address 172.17.0.2\n"
    printf "  dq find-by-ip-address 172.17.0.2 --only-return names --network foo\n"
    printf "  dq find-by-ip-address 172.17.0.2 --only-return ids\n"
    echo

  fi
}

# :command.usage
dq_names_only_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq names-only - Returns a list of names associated with all running containers.\n"
    echo

  else
    printf "dq names-only - Returns a list of names associated with all running containers.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq names-only [options]\n"
  printf "  dq names-only --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

  fi
}

# :command.usage
dq_ip_addresses_only_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq ip-addresses-only - Returns a list of IP addresses associated with the specified network.\n"
    echo

  else
    printf "dq ip-addresses-only - Returns a list of IP addresses associated with the specified network.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq ip-addresses-only [options]\n"
  printf "  dq ip-addresses-only --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --network NETWORK"
    printf "    Return IP addresses associated with the specified Docker network.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq ip-addresses-only --network foo\n"
    echo

  fi
}

# :command.usage
dq_env_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq env\n"
    echo

    printf "  Returns a block of sourceable environmental variables associated with the\n  specified container.\n  If no filters are specified, this command will return a distinct list of\n  variables from all running containers.\n"
    echo

  else
    printf "dq env - Returns a block of sourceable environmental variables associated with the specified container.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq env [options]\n"
  printf "  dq env --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --return-as RETURN"
    printf "    Return in the format of the supported values.\n"
    printf "    Allowed: block, flags\n"
    printf "    Default: block\n"
    echo

    # :flag.usage
    echo "  --name NAME (repeatable)"
    printf "    Return a block of variables associated with the given container name.\n"
    echo

    # :flag.usage
    echo "  --id ID (repeatable)"
    printf "    Return a block of variables associated with the given container id.\n"
    echo

    # :flag.usage
    echo "  --ip-address IP (repeatable)"
    printf "    Return a block of variables associated with the given IP address.\n"
    echo

    # :flag.usage
    echo "  --network NETWORK"
    printf "    Return IP addresses associated with the specified Docker network. This only\n    works when filtering while using the --ip-address flag.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq env\n"
    printf "  dq env --name merpflakes\n"
    printf "  dq env --id 9ae93171... --id 60d1114e... --id ade9aa44...\n"
    printf "  dq env --ip 172.17.0.2\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/docker_inspect.sh
docker_inspect() {
  container_ids=$(docker ps -q)
  [[ $(echo -n "${container_ids}" | wc -l | tr -d ' ') == 0 ]] && {

    echo '[]'
    return
  }

  docker inspect ${container_ids}
}

# src/lib/utils.sh
join () {
  local IFS="${1}"
  shift
  echo "${*}"
}

# :command.command_functions
# :command.function
dq_filter_command() {
  # src/filter_command.sh
  [[ -n "${args[--debug]}" ]] && set -x

  docker_inspect | jq -r "${args[filter]}"
}

# :command.function
dq_older_than_command() {
  # src/older_than_command.sh
  [[ -n "${args[--debug]}" ]] && set -x

  [[ ! "${other_args[*]}" ]] && {
    echo "$(red_bold [ERR]) Please, specify a GNU date-compatible relative time string."
    exit 1
  }

  if [[ "${OSTYPE}" == 'darwin'* ]]; then
    if ! command -v gdate &> /dev/null; then
      echo "$(red_bold [ERR]) gdate could not be located. Install using the following command:"
      echo "$(red_bold [ERR])   $ brew install coreutils"
      exit 1
    fi

    relative_epoch=$(gdate -d "${other_args[*]} ago" +%s)
  else
    relative_epoch=$(date -d "${other_args[*]} ago" +%s)
  fi

  filter='.[] | select((.State.StartedAt | split(".")[0] | "\(.)Z" | fromdate) < $threshold)'
  case "${args[--only-return]}" in
    ips)
      filter+=" | .NetworkSettings.Networks.${args[--network]}.IPAddress"
      ;;
    names)
      filter+=' | .Name[1:]'
      ;;
    ids)
      filter+=' | .Id'
      ;;
    *)
      filter="[${filter}]"
      ;;
  esac

  docker_inspect | jq --argjson threshold "${relative_epoch}" -r "${filter}"
}

# :command.function
dq_newer_than_command() {
  # src/newer_than_command.sh
  [[ -n "${args[--debug]}" ]] && set -x

  [[ ! "${other_args[*]}" ]] && {
    echo "$(red_bold [ERR]) Please, specify a GNU date-compatible relative time string."
    exit 1
  }

  if [[ "${OSTYPE}" == 'darwin'* ]]; then
    if ! command -v gdate &> /dev/null; then
      echo "$(red_bold [ERR]) gdate could not be located. Install using the following command:"
      echo "$(red_bold [ERR])   $ brew install coreutils"
      exit 1
    fi

    relative_epoch=$(gdate -d "${other_args[*]} ago" +%s)
  else
    relative_epoch=$(date -d "${other_args[*]} ago" +%s)
  fi

  filter='.[] | select((.State.StartedAt | split(".")[0] | "\(.)Z" | fromdate) > $threshold)'
  case "${args[--only-return]}" in
    ips)
      filter+=" | .NetworkSettings.Networks.${args[--network]}.IPAddress"
      ;;
    names)
      filter+=' | .Name[1:]'
      ;;
    ids)
      filter+=' | .Id'
      ;;
    *)
      filter="[${filter}]"
      ;;
  esac

  docker_inspect | jq --argjson threshold "${relative_epoch}" -r "${filter}"
}

# :command.function
dq_find_by_ip_address_command() {
  # src/find_by_ip_address_command.sh
  [[ -n "${args[--debug]}" ]] && set -x

  filter=".[] | select(.NetworkSettings.Networks.${args[--network]}.IPAddress == \"${args[ip]}\")"
  case "${args[--only-return]}" in
    names)
      filter+=' | .Name[1:]'
      ;;
    ids)
      filter+=' | .Id'
      ;;
    *)
      filter="[${filter}]"
      ;;
  esac

  docker_inspect | jq -r "${filter}"
}

# :command.function
dq_names_only_command() {
  # src/names_only_command.sh
  [[ -n "${args[--debug]}" ]] && set -x

  docker_inspect | jq -r '.[].Name[1:]'
}

# :command.function
dq_ip_addresses_only_command() {
  # src/ip_addresses_only_command.sh
  [[ -n "${args[--debug]}" ]] && set -x

  docker_inspect | jq -r ".[].NetworkSettings.Networks.${args[--network]}.IPAddress"
}

# :command.function
dq_env_command() {
  # src/env_command.sh
  [[ -n "${args[--debug]}" ]] && set -x

  filter='[.[].Config.Env] | flatten | unique'
  if [[ "${args[--name]}" ]]; then
    filter=".[] | select(.Name == \"/${args[--name]}\") | .Config.Env"
  elif [[ "${args[--id]}" ]]; then
    ids_arr=(${args[--id]})
    ids_str=$(join , "${ids_arr[@]}")

    filter="[.[] | select([.Id] | inside([${ids_str}])) | .Config.Env] | flatten | unique"
  elif [[ "${args[--ip-address]}" ]]; then
    filter=".[] | select(.NetworkSettings.Networks.${args[--network]}.IPAddress == \"${args[--ip-address]}\") | .Config.Env"
  fi

  if [[ "${args[--return-as]}" == 'flags' ]]; then
    filter="[${filter} | \"--env=\(.[])\"] | join(\" \")"
  else
    filter+=' | .[]'
  fi

  docker_inspect | jq -r "${filter}"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    dq_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  filter )
    action="filter"
    shift
    dq_filter_parse_requirements "$@"
    shift $#
    ;;

  older-than )
    action="older-than"
    shift
    dq_older_than_parse_requirements "$@"
    shift $#
    ;;

  newer-than )
    action="newer-than"
    shift
    dq_newer_than_parse_requirements "$@"
    shift $#
    ;;

  find-by-ip-address )
    action="find-by-ip-address"
    shift
    dq_find_by_ip_address_parse_requirements "$@"
    shift $#
    ;;

  names-only )
    action="names-only"
    shift
    dq_names_only_parse_requirements "$@"
    shift $#
    ;;

  ip-addresses-only )
    action="ip-addresses-only"
    shift
    dq_ip_addresses_only_parse_requirements "$@"
    shift $#
    ;;

  env )
    action="env"
    shift
    dq_env_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    dq_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
dq_filter_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_filter_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="filter"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[filter]+x} ]]; then

        args[filter]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
dq_older_than_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_older_than_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="older-than"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --only-return )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--only-return]="$2"
        shift
        shift
      else
        printf "%s\n" "--only-return requires an argument: --only-return RETURN"
        exit 1
      fi
      ;;

    # :flag.case
    --network )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network NETWORK"
        exit 1
      fi
      ;;

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_catch_all
      other_args+=("$1")
      shift

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[--only-return]:-} ]] || args[--only-return]="json"
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

  # :command.whitelist_filter
  if [[ ! ${args[--only-return]} =~ ^(ips|names|ids|json)$ ]]; then
    printf "%s\n" "--only-return must be one of: ips, names, ids, json"
    exit 1
  fi

}

# :command.parse_requirements
dq_newer_than_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_newer_than_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="newer-than"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --only-return )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--only-return]="$2"
        shift
        shift
      else
        printf "%s\n" "--only-return requires an argument: --only-return RETURN"
        exit 1
      fi
      ;;

    # :flag.case
    --network | -n )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network, -n NETWORK"
        exit 1
      fi
      ;;

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_catch_all
      other_args+=("$1")
      shift

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[--only-return]:-} ]] || args[--only-return]="json"
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

  # :command.whitelist_filter
  if [[ ! ${args[--only-return]} =~ ^(ips|names|ids|json)$ ]]; then
    printf "%s\n" "--only-return must be one of: ips, names, ids, json"
    exit 1
  fi

}

# :command.parse_requirements
dq_find_by_ip_address_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_find_by_ip_address_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="find-by-ip-address"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --only-return )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--only-return]="$2"
        shift
        shift
      else
        printf "%s\n" "--only-return requires an argument: --only-return RETURN"
        exit 1
      fi
      ;;

    # :flag.case
    --network )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network NETWORK"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[ip]+x} ]]; then

        args[ip]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[ip]+x} ]]; then
    printf "missing required argument: IP\nusage: dq find-by-ip-address IP [options]\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--only-return]:-} ]] || args[--only-return]="json"
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

  # :command.whitelist_filter
  if [[ ! ${args[--only-return]} =~ ^(names|ids|json)$ ]]; then
    printf "%s\n" "--only-return must be one of: names, ids, json"
    exit 1
  fi

}

# :command.parse_requirements
dq_names_only_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_names_only_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="names-only"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
dq_ip_addresses_only_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_ip_addresses_only_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="ip-addresses-only"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --network )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network NETWORK"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

}

# :command.parse_requirements
dq_env_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_env_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="env"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --return-as )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--return-as]="$2"
        shift
        shift
      else
        printf "%s\n" "--return-as requires an argument: --return-as RETURN"
        exit 1
      fi
      ;;

    # :flag.case
    --name )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        if [[ -z ${args[--name]+x} ]]; then
          args[--name]="\"$2\""
        else
          args[--name]="${args[--name]} \"$2\""
        fi
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name NAME"
        exit 1
      fi
      ;;

    # :flag.case
    --id )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        if [[ -z ${args[--id]+x} ]]; then
          args[--id]="\"$2\""
        else
          args[--id]="${args[--id]} \"$2\""
        fi
        shift
        shift
      else
        printf "%s\n" "--id requires an argument: --id ID"
        exit 1
      fi
      ;;

    # :flag.case
    --ip-address )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        if [[ -z ${args[--ip-address]+x} ]]; then
          args[--ip-address]="\"$2\""
        else
          args[--ip-address]="${args[--ip-address]} \"$2\""
        fi
        shift
        shift
      else
        printf "%s\n" "--ip-address requires an argument: --ip-address IP"
        exit 1
      fi
      ;;

    # :flag.case
    --network )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network NETWORK"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[--return-as]:-} ]] || args[--return-as]="block"
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

  # :command.whitelist_filter
  if [[ ! ${args[--return-as]} =~ ^(block|flags)$ ]]; then
    printf "%s\n" "--return-as must be one of: block, flags"
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="1.1.0"
  long_usage=''
  set -e

  # src/initialize.sh
  set -eo pipefail

  if ! command -v "jq" &> /dev/null; then
    echo "$(red_bold [ERR]) jq could not be located. Install using the relevant command:"
    echo "$(red_bold [ERR])   MacOS: $ brew update && brew install jq"
    echo "$(red_bold [ERR])   Linux: $ apt-get install jq"
  fi
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "filter" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_filter_usage
    else
      dq_filter_command
    fi

  elif [[ $action == "older-than" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_older_than_usage
    else
      dq_older_than_command
    fi

  elif [[ $action == "newer-than" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_newer_than_usage
    else
      dq_newer_than_command
    fi

  elif [[ $action == "find-by-ip-address" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_find_by_ip_address_usage
    else
      dq_find_by_ip_address_command
    fi

  elif [[ $action == "names-only" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_names_only_usage
    else
      dq_names_only_command
    fi

  elif [[ $action == "ip-addresses-only" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_ip_addresses_only_usage
    else
      dq_ip_addresses_only_command
    fi

  elif [[ $action == "env" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_env_usage
    else
      dq_env_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
