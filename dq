#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dq_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq - Filter your local running Docker containers using jq.\n"
    echo 
  else
    printf "dq - Filter your local running Docker containers using jq.\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dq [command]\n"
  printf "  dq [command] --help | -h\n"
  printf "  dq --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  filter   Run a free-form jq filter against your local running Docker containers."
  echo "  common   A list of commonly-used and convenient filters."
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dq_filter_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq filter - Run a free-form jq filter against your local running Docker containers.\n"
    echo 
  else
    printf "dq filter - Run a free-form jq filter against your local running Docker containers.\n"
    echo 
  fi

  printf "Shortcut: f\n"
  echo

  printf "Usage:\n"
  printf "  dq filter [FILTER]\n"
  printf "  dq filter --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  FILTER"
    printf "    The filter to apply to docker inspect's JSON output.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  dq filter '. | length'\n"
    printf "  dq filter '.[].Name[1:]'\n"
    printf "  dq f '.[].Id'\n"
    echo

  fi
}

# :command.usage
dq_common_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common - A list of commonly-used and convenient filters.\n"
    echo 
  else
    printf "dq common - A list of commonly-used and convenient filters.\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dq common [command]\n"
  printf "  dq common [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  older-than           Return a list of containers older than the given relative time. Please note this command relies on the GNU version of date."
  echo "  newer-than           Return a list of containers newer than the given relative time. Please note this command relies on the GNU version of date."
  echo "  find-by-ip-address   Return a list of containers assigned the given IP address."
  echo "  names-only           Returns a list of names associated with all running containers."
  echo "  ip-addresses-only    Returns a list of IP addresses associated with the specified network."
  echo "  env-block            Returns a block of sourceable environmental variables associated with the specified container. If no filters are specified, this command will return a distinct list of variables from all running containers."
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dq_common_older_than_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common older-than\n"
    echo 
    printf "  Return a list of containers older than the given relative time. Please note\n  this command relies on the GNU version of date.\n"
    echo 
  else
    printf "dq common older-than - Return a list of containers older than the given relative time. Please note this command relies on the GNU version of date.\n"
    echo 
  fi

  printf "Shortcut: ot\n"
  echo

  printf "Usage:\n"
  printf "  dq common older-than [options] [DATE STRING...]\n"
  printf "  dq common older-than --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --return-ids-only"
    printf "    Return only container ids.\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    echo "  DATE STRING..."
    printf "    A GNU date-compatible relative time string.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  dq common older-than 4 months\n"
    printf "  dq common older-than 34 seconds\n"
    printf "  dq common older-than 2 fortnights --return-ids-only\n"
    echo

  fi
}

# :command.usage
dq_common_newer_than_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common newer-than\n"
    echo 
    printf "  Return a list of containers newer than the given relative time. Please note\n  this command relies on the GNU version of date.\n"
    echo 
  else
    printf "dq common newer-than - Return a list of containers newer than the given relative time. Please note this command relies on the GNU version of date.\n"
    echo 
  fi

  printf "Shortcut: nt\n"
  echo

  printf "Usage:\n"
  printf "  dq common newer-than [options] [DATE STRING...]\n"
  printf "  dq common newer-than --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --return-ids-only"
    printf "    Return only container ids.\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    echo "  DATE STRING..."
    printf "    A GNU date-compatible relative time string.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  dq common newer-than 4 months\n"
    printf "  dq common newer-than 34 seconds\n"
    printf "  dq common newer-than 2 fortnights --return-ids-only\n"
    echo

  fi
}

# :command.usage
dq_common_find_by_ip_address_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common find-by-ip-address - Return a list of containers assigned the given IP address.\n"
    echo 
  else
    printf "dq common find-by-ip-address - Return a list of containers assigned the given IP address.\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dq common find-by-ip-address IP [options]\n"
  printf "  dq common find-by-ip-address --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --network, -n NETWORK"
    printf "    Return IP addresses associated with the specified Docker network.\n"
    printf "    Default: bridge\n"
    echo
    
    # :flag.usage
    echo "  --return-ids-only"
    printf "    Return only container ids.\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  IP"
    printf "    The IP address associated with the desired container.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  dq common find-by-ip-address 172.17.0.2\n"
    printf "  dq common find-by-ip-address 172.17.0.2 --network foo\n"
    printf "  dq common find-by-ip-address 172.17.0.2 --network foo --return-ids-only\n"
    echo

  fi
}

# :command.usage
dq_common_names_only_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common names-only - Returns a list of names associated with all running containers.\n"
    echo 
  else
    printf "dq common names-only - Returns a list of names associated with all running containers.\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dq common names-only\n"
  printf "  dq common names-only --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dq_common_ip_addresses_only_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common ip-addresses-only - Returns a list of IP addresses associated with the specified network.\n"
    echo 
  else
    printf "dq common ip-addresses-only - Returns a list of IP addresses associated with the specified network.\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dq common ip-addresses-only [options]\n"
  printf "  dq common ip-addresses-only --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --network, -n NETWORK"
    printf "    Return IP addresses associated with the specified Docker network.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  dq common ip-addresses-only --network foo\n"
    echo

  fi
}

# :command.usage
dq_common_env_block_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common env-block\n"
    echo 
    printf "  Returns a block of sourceable environmental variables associated with the\n  specified container. If no filters are specified, this command will return a\n  distinct list of variables from all running containers.\n"
    echo 
  else
    printf "dq common env-block - Returns a block of sourceable environmental variables associated with the specified container. If no filters are specified, this command will return a distinct list of variables from all running containers.\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dq common env-block [options]\n"
  printf "  dq common env-block --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --name NAME"
    printf "    Return a block of variables associated with the given container name.\n"
    echo
    
    # :flag.usage
    echo "  --id ID"
    printf "    Return a block of variables associated with the given container id.\n"
    echo
    
    # :flag.usage
    echo "  --ip-address, -ip IP"
    printf "    Return a block of variables associated with the given IP address.\n"
    echo
    
    # :flag.usage
    echo "  --network, -n NETWORK"
    printf "    Used with --ip-address to target a specific Docker network.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  dq common env-block\n"
    printf "  dq common env-block --name merpflakes\n"
    printf "  dq common env-block --id 6353d5af14f661e3e3...\n"
    printf "  dq common env-block --ip 172.17.0.2\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# :src/lib/docker_inspect.sh
docker_inspect() {
  docker inspect $(docker ps -q)
}

# :command.command_functions
# :command.function
dq_filter_command() {
  # :src/filter_command.sh
  docker_inspect | jq -r "${args[filter]}"
}

# :command.function
dq_common_older_than_command() {
  # :src/common_older_than_command.sh
  if [[ "${OSTYPE}" == 'darwin'* ]]; then
    if ! command -v gdate &> /dev/null; then
      echo 'Please, install gdate before continuing. You can do this using Homebrew with:'
      echo '$ brew install coreutils'
      exit 1
    fi
  
    relative_epoch=$(gdate -d "${other_args[*]} ago" +%s)
  else
    relative_epoch=$(date -d "${other_args[*]} ago" +%s)
  fi
  
  filter='.[] | select((.State.StartedAt | split(".")[0] | "\(.)Z" | fromdate) < $threshold) | '
  if [[ "${args[--return-ids-only]}" ]]; then
    filter+='.Id'
  else
    filter+='.Name[1:]'
  fi
  
  docker_inspect | jq --argjson threshold "${relative_epoch}" -r "${filter}"
}

# :command.function
dq_common_newer_than_command() {
  # :src/common_newer_than_command.sh
  if [[ "${OSTYPE}" == 'darwin'* ]]; then
    if ! command -v gdate &> /dev/null; then
      echo 'Please, install gdate before continuing. You can do this using Homebrew with:'
      echo '$ brew install coreutils'
      exit 1
    fi
  
    relative_epoch=$(gdate -d "${other_args[*]} ago" +%s)
  else
    relative_epoch=$(date -d "${other_args[*]} ago" +%s)
  fi
  
  filter='.[] | select((.State.StartedAt | split(".")[0] | "\(.)Z" | fromdate) > $threshold) | '
  if [[ "${args[--return-ids-only]}" ]]; then
    filter+='.Id'
  else
    filter+='.Name[1:]'
  fi
  
  docker_inspect | jq --argjson threshold "${relative_epoch}" -r "${filter}"
}

# :command.function
dq_common_find_by_ip_address_command() {
  # :src/common_find_by_ip_address_command.sh
  filter='.[] | select(.NetworkSettings.Networks[$network].IPAddress == $ip)'
  if [[ "${args[--return-ids-only]}" ]]; then
      filter+=' | .Id'
  else
      filter+=' | .Name[1:]'
  fi
  
  docker_inspect | jq \
      --arg network "${args[--network]}" \
      --arg ip "${args[ip]}" \
      -r "${filter}"
}

# :command.function
dq_common_names_only_command() {
  # :src/common_names_only_command.sh
  docker_inspect | jq -r '.[].Name[1:]'
}

# :command.function
dq_common_ip_addresses_only_command() {
  # :src/common_ip_addresses_only_command.sh
  docker_inspect | jq --arg network "${args[--network]}" -r '.[].NetworkSettings.Networks[$network].IPAddress'
}

# :command.function
dq_common_env_block_command() {
  # :src/common_env_block_command.sh
  JQ_OPTS=
  filter='[.[].Config.Env] | flatten | unique | .[]'
  if [[ "${args[--name]}" ]]; then
    JQ_OPTS="--arg name ${args[--name]}"
    filter='.[] | select(.Name == "/\($name)") | .Config.Env | .[]'
  elif [[ "${args[--id]}" ]]; then
    JQ_OPTS="--arg id ${args[--id]}"
    filter='.[] | select(.Id == $id) | .Config.Env | .[]'
  elif [[ "${args[--ip-address]}" ]]; then
    JQ_OPTS="--arg network ${args[--network]} --arg ip ${args[--ip-address]}"
    filter='.[] | select(.NetworkSettings.Networks[$network].IPAddress == $ip) | .Config.Env | .[]'
  fi
  
  docker_inspect | jq ${JQ_OPTS} -r "${filter}"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;
  
  filter | f )
    action="filter"
    shift
    dq_filter_parse_requirements "$@"
    shift $#
    ;;    
  
  common )
    action="common"
    shift
    dq_common_parse_requirements "$@"
    shift $#
    ;;    
  
  # :command.command_fallback
  * )
    dq_usage
    exit 1
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dq_filter_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_filter_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="filter"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[filter]} ]]; then
        args[filter]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dq_common_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_common_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;
  
  older-than | ot )
    action="older-than"
    shift
    dq_common_older_than_parse_requirements "$@"
    shift $#
    ;;    
  
  newer-than | nt )
    action="newer-than"
    shift
    dq_common_newer_than_parse_requirements "$@"
    shift $#
    ;;    
  
  find-by-ip-address )
    action="find-by-ip-address"
    shift
    dq_common_find_by_ip_address_parse_requirements "$@"
    shift $#
    ;;    
  
  names-only )
    action="names-only"
    shift
    dq_common_names_only_parse_requirements "$@"
    shift $#
    ;;    
  
  ip-addresses-only )
    action="ip-addresses-only"
    shift
    dq_common_ip_addresses_only_parse_requirements "$@"
    shift $#
    ;;    
  
  env-block )
    action="env-block"
    shift
    dq_common_env_block_parse_requirements "$@"
    shift $#
    ;;    
  
  # :command.command_fallback
  * )
    dq_common_usage
    exit 1
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dq_common_older_than_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_common_older_than_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="common older-than"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --return-ids-only )
      args[--return-ids-only]=1
      shift
      ;;
  
  
    -* )
      other_args+=("$1")
      shift
      ;;
  
    * )
      # :command.parse_requirements_case
        other_args+=("$1")
        shift
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dq_common_newer_than_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_common_newer_than_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="common newer-than"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --return-ids-only )
      args[--return-ids-only]=1
      shift
      ;;
  
  
    -* )
      other_args+=("$1")
      shift
      ;;
  
    * )
      # :command.parse_requirements_case
        other_args+=("$1")
        shift
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dq_common_find_by_ip_address_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_common_find_by_ip_address_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="common find-by-ip-address"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[ip]=$1
    shift
  else
    printf "missing required argument: IP\nusage: dq common find-by-ip-address IP [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --network | -n )
      if [[ $2 ]]; then
        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network, -n NETWORK"
        exit 1
      fi
      ;;
  
    # :flag.case
    --return-ids-only )
      args[--return-ids-only]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[ip]} ]]; then
        args[ip]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--network]} ]] || args[--network]="bridge"
  # :command.whitelist_filter
}

# :command.parse_requirements
dq_common_names_only_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_common_names_only_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="common names-only"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dq_common_ip_addresses_only_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_common_ip_addresses_only_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="common ip-addresses-only"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --network | -n )
      if [[ $2 ]]; then
        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network, -n NETWORK"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--network]} ]] || args[--network]="bridge"
  # :command.whitelist_filter
}

# :command.parse_requirements
dq_common_env_block_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dq_common_env_block_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="common env-block"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --name )
      if [[ $2 ]]; then
        args[--name]="$2"
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name NAME"
        exit 1
      fi
      ;;
  
    # :flag.case
    --id )
      if [[ $2 ]]; then
        args[--id]="$2"
        shift
        shift
      else
        printf "%s\n" "--id requires an argument: --id ID"
        exit 1
      fi
      ;;
  
    # :flag.case
    --ip-address | -ip )
      if [[ $2 ]]; then
        args[--ip-address]="$2"
        shift
        shift
      else
        printf "%s\n" "--ip-address requires an argument: --ip-address, -ip IP"
        exit 1
      fi
      ;;
  
    # :flag.case
    --network | -n )
      if [[ $2 ]]; then
        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network, -n NETWORK"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--network]} ]] || args[--network]="bridge"
  # :command.whitelist_filter
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
    printf "bash version 4 or higher is required\n"
    exit 1
  fi

  # :src/initialize.sh
  set -eo pipefail
  
  [[ -n "${VERBOSE}" ]] && set -x
  
  if ! command -v jq &> /dev/null; then
    echo 'Please, install jq before continuing: https://stedolan.github.io/jq/download/'
    exit 1
  fi
}

# :command.run
run() {
  declare -A args
  declare -a other_args
  declare -a input
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "filter" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dq_filter_usage
    else
      dq_filter_command
    fi
  
  elif [[ $action == "common" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dq_common_usage
    else
      dq_common_command
    fi
  
  elif [[ $action == "common older-than" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dq_common_older_than_usage
    else
      dq_common_older_than_command
    fi
  
  elif [[ $action == "common newer-than" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dq_common_newer_than_usage
    else
      dq_common_newer_than_command
    fi
  
  elif [[ $action == "common find-by-ip-address" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dq_common_find_by_ip_address_usage
    else
      dq_common_find_by_ip_address_command
    fi
  
  elif [[ $action == "common names-only" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dq_common_names_only_usage
    else
      dq_common_names_only_command
    fi
  
  elif [[ $action == "common ip-addresses-only" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dq_common_ip_addresses_only_usage
    else
      dq_common_ip_addresses_only_command
    fi
  
  elif [[ $action == "common env-block" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dq_common_env_block_usage
    else
      dq_common_env_block_command
    fi
  
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
