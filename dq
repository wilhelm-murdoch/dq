#!/usr/bin/env bash
# This script was generated by bashly 0.8.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dq_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq - A wrapper around Docker and jq that allows you to filter running Docker containers.\n"
    echo

  else
    printf "dq - A wrapper around Docker and jq that allows you to filter running Docker containers.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq [command]\n"
  printf "  dq [command] --help | -h\n"
  printf "  dq --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  filter   Run a free-form jq filter against your local running Docker containers."
  echo "  common   A list of commonly-used and convenient filters."
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dq_filter_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq filter - Run a free-form jq filter against your local running Docker containers.\n"
    echo

  else
    printf "dq filter - Run a free-form jq filter against your local running Docker containers.\n"
    echo

  fi

  printf "Alias: f\n"
  echo

  printf "Usage:\n"
  printf "  dq filter [FILTER] [options]\n"
  printf "  dq filter --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  FILTER"
    printf "    The filter to apply to docker inspect's JSON output.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq filter '. | length'\n"
    printf "  dq filter '.[].Name[1:]'\n"
    printf "  dq f '.[].Id'\n"
    echo

  fi
}

# :command.usage
dq_common_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common - A list of commonly-used and convenient filters.\n"
    echo

  else
    printf "dq common - A list of commonly-used and convenient filters.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq common [command]\n"
  printf "  dq common [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  older-than           Return a list of containers older than the given relative time. Please note this command relies on the GNU version of date."
  echo "  newer-than           Return a list of containers older than the given relative time. Please note this command relies on the GNU version of date."
  echo "  find-by-ip-address   Return a list of containers assigned the given IP address."
  echo "  names-only           Returns a list of names associated with all running containers."
  echo "  ip-addresses-only    Returns a list of IP addresses associated with the specified network."
  echo "  env                  Returns a block of sourceable environmental variables associated with the specified container. If no filters are specified, this command will return a distinct list of variables from all running containers."
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dq_common_older_than_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common older-than\n"
    echo

    printf "  Return a list of containers older than the given relative time. Please note\n  this command relies on the GNU version of date.\n"
    echo

  else
    printf "dq common older-than - Return a list of containers older than the given relative time. Please note this command relies on the GNU version of date.\n"
    echo

  fi

  printf "Alias: ot\n"
  echo

  printf "Usage:\n"
  printf "  dq common older-than [options] [DATE STRING...]\n"
  printf "  dq common older-than --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --only-return RETURN"
    printf "    Return the supported values instead of matching JSON.\n"
    printf "    Allowed: ips, names, ids, json\n"
    printf "    Default: json\n"
    echo

    # :flag.usage
    echo "  --network NETWORK"
    printf "    Return IP addresses associated with the specified Docker network. This only\n    works when returning ips with the --only-return flag.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    echo "  DATE STRING..."
    printf "    A GNU date-compatible relative time string.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq common older-than 4 months --only-return ips --network pebkac\n"
    printf "  dq common older-than 34 seconds\n"
    printf "  dq common older-than 2 fortnights --only-return ids\n"
    echo

  fi
}

# :command.usage
dq_common_newer_than_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common newer-than\n"
    echo

    printf "  Return a list of containers older than the given relative time. Please note\n  this command relies on the GNU version of date.\n"
    echo

  else
    printf "dq common newer-than - Return a list of containers older than the given relative time. Please note this command relies on the GNU version of date.\n"
    echo

  fi

  printf "Alias: nt\n"
  echo

  printf "Usage:\n"
  printf "  dq common newer-than [options] [DATE STRING...]\n"
  printf "  dq common newer-than --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --only-return RETURN"
    printf "    Return the supported values instead of matching JSON.\n"
    printf "    Allowed: ips, names, ids, json\n"
    printf "    Default: json\n"
    echo

    # :flag.usage
    echo "  --network, -n NETWORK"
    printf "    Return IP addresses associated with the specified Docker network. This only\n    works when returning ips with the --only-return flag.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    echo "  DATE STRING..."
    printf "    A GNU date-compatible relative time string.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq common newer-than 4 months --only-return ips --network pebkac\n"
    printf "  dq common newer-than 34 seconds\n"
    printf "  dq common newer-than 2 fortnights --only-return ids\n"
    echo

  fi
}

# :command.usage
dq_common_find_by_ip_address_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common find-by-ip-address - Return a list of containers assigned the given IP address.\n"
    echo

  else
    printf "dq common find-by-ip-address - Return a list of containers assigned the given IP address.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq common find-by-ip-address IP [options]\n"
  printf "  dq common find-by-ip-address --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --only-return RETURN"
    printf "    Return the supported values instead of matching JSON.\n"
    printf "    Allowed: names, ids, json\n"
    printf "    Default: json\n"
    echo

    # :flag.usage
    echo "  --network NETWORK"
    printf "    Return IP addresses associated with the specified Docker network.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  IP"
    printf "    The IP address associated with the desired container.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq common find-by-ip-address 172.17.0.2\n"
    printf "  dq common find-by-ip-address 172.17.0.2 --only-return names --network foo\n"
    printf "  dq common find-by-ip-address 172.17.0.2 --only-return ids\n"
    echo

  fi
}

# :command.usage
dq_common_names_only_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common names-only - Returns a list of names associated with all running containers.\n"
    echo

  else
    printf "dq common names-only - Returns a list of names associated with all running containers.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq common names-only [options]\n"
  printf "  dq common names-only --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

  fi
}

# :command.usage
dq_common_ip_addresses_only_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common ip-addresses-only - Returns a list of IP addresses associated with the specified network.\n"
    echo

  else
    printf "dq common ip-addresses-only - Returns a list of IP addresses associated with the specified network.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq common ip-addresses-only [options]\n"
  printf "  dq common ip-addresses-only --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --network NETWORK"
    printf "    Return IP addresses associated with the specified Docker network.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq common ip-addresses-only --network foo\n"
    echo

  fi
}

# :command.usage
dq_common_env_usage() {
  if [[ -n $long_usage ]]; then
    printf "dq common env\n"
    echo

    printf "  Returns a block of sourceable environmental variables associated with the\n  specified container. If no filters are specified, this command will return a\n  distinct list of variables from all running containers.\n"
    echo

  else
    printf "dq common env - Returns a block of sourceable environmental variables associated with the specified container. If no filters are specified, this command will return a distinct list of variables from all running containers.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dq common env [options]\n"
  printf "  dq common env --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash. Useful for troubleshooting commands.\n"
    echo

    # :flag.usage
    echo "  --return-as RETURN"
    printf "    Return in the format of the supported values.\n"
    printf "    Allowed: block, flags\n"
    printf "    Default: block\n"
    echo

    # :flag.usage
    echo "  --name NAME"
    printf "    Return a block of variables associated with the given container name.\n"
    echo

    # :flag.usage
    echo "  --id ID"
    printf "    Return a block of variables associated with the given container id.\n"
    echo

    # :flag.usage
    echo "  --ip-address IP"
    printf "    Return a block of variables associated with the given IP address.\n"
    echo

    # :flag.usage
    echo "  --network NETWORK"
    printf "    Return IP addresses associated with the specified Docker network. This only\n    works when filtering while using the --ip-address flag.\n"
    printf "    Default: bridge\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  dq common env\n"
    printf "  dq common env --name merpflakes\n"
    printf "  dq common env --id 6353d5af14f661e3e3...\n"
    printf "  dq common env --ip 172.17.0.2\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/docker_inspect.sh
docker_inspect() {
  docker inspect $(docker ps -q)
}

# :command.command_functions
# :command.function
dq_filter_command() {
  # src/filter_command.sh
  docker_inspect | jq -r "${args[filter]}"
}

# :command.function
dq_common_older_than_command() {
  # src/common_older_than_command.sh
  [[ ! "${other_args[*]}" ]] && {
    echo "$(red_bold [ERR]) Please, specify a GNU date-compatible relative time string."
    exit 1
  }

  if [[ "${OSTYPE}" == 'darwin'* ]]; then
    if ! command -v gdate &> /dev/null; then
      echo "$(red_bold [ERR]) gdate could not be located. Install using the following command:"
      echo "$(red_bold [ERR])   $ brew install coreutils"
      exit 1
    fi

    relative_epoch=$(gdate -d "${other_args[*]} ago" +%s)
  else
    relative_epoch=$(date -d "${other_args[*]} ago" +%s)
  fi

  filter='.[] | select((.State.StartedAt | split(".")[0] | "\(.)Z" | fromdate) < $threshold)'
  case "${args[--only-return]}" in
    ips)
      filter+=" | .NetworkSettings.Networks.${args[--network]}.IPAddress"
      ;;
    names)
      filter+=' | .Name[1:]'
      ;;
    ids)
      filter+=' | .Id'
      ;;
    *)
      filter="[${filter}]"
      ;;
  esac

  docker_inspect | jq --argjson threshold "${relative_epoch}" -r "${filter}"
}

# :command.function
dq_common_newer_than_command() {
  # src/common_newer_than_command.sh
  [[ ! "${other_args[*]}" ]] && {
    echo "$(red_bold [ERR]) Please, specify a GNU date-compatible relative time string."
    exit 1
  }

  if [[ "${OSTYPE}" == 'darwin'* ]]; then
    if ! command -v gdate &> /dev/null; then
      echo "$(red_bold [ERR]) gdate could not be located. Install using the following command:"
      echo "$(red_bold [ERR])   $ brew install coreutils"
      exit 1
    fi

    relative_epoch=$(gdate -d "${other_args[*]} ago" +%s)
  else
    relative_epoch=$(date -d "${other_args[*]} ago" +%s)
  fi

  filter='.[] | select((.State.StartedAt | split(".")[0] | "\(.)Z" | fromdate) > $threshold)'
  case "${args[--only-return]}" in
    ips)
      filter+=" | .NetworkSettings.Networks.${args[--network]}.IPAddress"
      ;;
    names)
      filter+=' | .Name[1:]'
      ;;
    ids)
      filter+=' | .Id'
      ;;
    *)
      filter="[${filter}]"
      ;;
  esac

  docker_inspect | jq --argjson threshold "${relative_epoch}" -r "${filter}"
}

# :command.function
dq_common_find_by_ip_address_command() {
  # src/common_find_by_ip_address_command.sh
  filter=".[] | select(.NetworkSettings.Networks.${args[--network]}.IPAddress == \"${args[ip]}\")"
  case "${args[--only-return]}" in
    names)
      filter+=' | .Name[1:]'
      ;;
    ids)
      filter+=' | .Id'
      ;;
    *)
      filter="[${filter}]"
      ;;
  esac

  docker_inspect | jq -r "${filter}"
}

# :command.function
dq_common_names_only_command() {
  # src/common_names_only_command.sh
  docker_inspect | jq -r '.[].Name[1:]'
}

# :command.function
dq_common_ip_addresses_only_command() {
  # src/common_ip_addresses_only_command.sh
  docker_inspect | jq -r ".[].NetworkSettings.Networks.${args[--network]}.IPAddress"
}

# :command.function
dq_common_env_command() {
  # src/common_env_command.sh
  filter='[.[].Config.Env] | flatten | unique'
  if [[ "${args[--name]}" ]]; then
    filter=".[] | select(.Name == \"/${args[--name]}\") | .Config.Env"
  elif [[ "${args[--id]}" ]]; then
    filter=".[] | select(.Id == ${args[--id]}) | .Config.Env"
  elif [[ "${args[--ip-address]}" ]]; then
    filter=".[] | select(.NetworkSettings.Networks.${args[--network]}.IPAddress == \"${args[--ip-address]}\") | .Config.Env"
  fi

  if [[ "${args[--return-as]}" == 'flags' ]]; then
    filter="[${filter} | \"--env=\(.[])\"] | join(\" \")"
  else
    filter+=' | .[]'
  fi

  docker_inspect | jq -r "${filter}"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    dq_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  filter | f )
    action="filter"
    shift
    dq_filter_parse_requirements "$@"
    shift $#
    ;;

  common )
    action="common"
    shift
    dq_common_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    dq_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
dq_filter_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_filter_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="filter"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[filter]+x} ]]; then

        args[filter]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
dq_common_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_common_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  older-than | ot )
    action="older-than"
    shift
    dq_common_older_than_parse_requirements "$@"
    shift $#
    ;;

  newer-than | nt )
    action="newer-than"
    shift
    dq_common_newer_than_parse_requirements "$@"
    shift $#
    ;;

  find-by-ip-address )
    action="find-by-ip-address"
    shift
    dq_common_find_by_ip_address_parse_requirements "$@"
    shift $#
    ;;

  names-only )
    action="names-only"
    shift
    dq_common_names_only_parse_requirements "$@"
    shift $#
    ;;

  ip-addresses-only )
    action="ip-addresses-only"
    shift
    dq_common_ip_addresses_only_parse_requirements "$@"
    shift $#
    ;;

  env )
    action="env"
    shift
    dq_common_env_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    dq_common_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
dq_common_older_than_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_common_older_than_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="common older-than"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --only-return )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--only-return]="$2"
        shift
        shift
      else
        printf "%s\n" "--only-return requires an argument: --only-return RETURN"
        exit 1
      fi
      ;;

    # :flag.case
    --network )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network NETWORK"
        exit 1
      fi
      ;;

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_catch_all
      other_args+=("$1")
      shift

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[--only-return]:-} ]] || args[--only-return]="json"
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

  # :command.whitelist_filter
  if [[ ! ${args[--only-return]} =~ ^(ips|names|ids|json)$ ]]; then
    printf "%s\n" "--only-return must be one of: ips, names, ids, json"
    exit 1
  fi

}

# :command.parse_requirements
dq_common_newer_than_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_common_newer_than_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="common newer-than"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --only-return )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--only-return]="$2"
        shift
        shift
      else
        printf "%s\n" "--only-return requires an argument: --only-return RETURN"
        exit 1
      fi
      ;;

    # :flag.case
    --network | -n )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network, -n NETWORK"
        exit 1
      fi
      ;;

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_catch_all
      other_args+=("$1")
      shift

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[--only-return]:-} ]] || args[--only-return]="json"
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

  # :command.whitelist_filter
  if [[ ! ${args[--only-return]} =~ ^(ips|names|ids|json)$ ]]; then
    printf "%s\n" "--only-return must be one of: ips, names, ids, json"
    exit 1
  fi

}

# :command.parse_requirements
dq_common_find_by_ip_address_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_common_find_by_ip_address_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="common find-by-ip-address"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --only-return )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--only-return]="$2"
        shift
        shift
      else
        printf "%s\n" "--only-return requires an argument: --only-return RETURN"
        exit 1
      fi
      ;;

    # :flag.case
    --network )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network NETWORK"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[ip]+x} ]]; then

        args[ip]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[ip]+x} ]]; then
    printf "missing required argument: IP\nusage: dq common find-by-ip-address IP [options]\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--only-return]:-} ]] || args[--only-return]="json"
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

  # :command.whitelist_filter
  if [[ ! ${args[--only-return]} =~ ^(names|ids|json)$ ]]; then
    printf "%s\n" "--only-return must be one of: names, ids, json"
    exit 1
  fi

}

# :command.parse_requirements
dq_common_names_only_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_common_names_only_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="common names-only"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
dq_common_ip_addresses_only_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_common_ip_addresses_only_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="common ip-addresses-only"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --network )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network NETWORK"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

}

# :command.parse_requirements
dq_common_env_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dq_common_env_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="common env"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    # :flag.case
    --return-as )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--return-as]="$2"
        shift
        shift
      else
        printf "%s\n" "--return-as requires an argument: --return-as RETURN"
        exit 1
      fi
      ;;

    # :flag.case
    --name )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--name]="$2"
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name NAME"
        exit 1
      fi
      ;;

    # :flag.case
    --id )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--id]="$2"
        shift
        shift
      else
        printf "%s\n" "--id requires an argument: --id ID"
        exit 1
      fi
      ;;

    # :flag.case
    --ip-address )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--ip-address]="$2"
        shift
        shift
      else
        printf "%s\n" "--ip-address requires an argument: --ip-address IP"
        exit 1
      fi
      ;;

    # :flag.case
    --network )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--network]="$2"
        shift
        shift
      else
        printf "%s\n" "--network requires an argument: --network NETWORK"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[--return-as]:-} ]] || args[--return-as]="block"
  [[ -n ${args[--network]:-} ]] || args[--network]="bridge"

  # :command.whitelist_filter
  if [[ ! ${args[--return-as]} =~ ^(block|flags)$ ]]; then
    printf "%s\n" "--return-as must be one of: block, flags"
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh
  set -eo pipefail

  [[ -n "${args[--debug]}" ]] && set -x

  if ! command -v "jq" &> /dev/null; then
    echo "$(red_bold [ERR]) jq could not be located. Install using the relevant command:"
    echo "$(red_bold [ERR])   MacOS: $ brew update && brew install jq"
    echo "$(red_bold [ERR])   Linux: $ apt-get install jq"
  fi
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "filter" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_filter_usage
    else
      dq_filter_command
    fi

  elif [[ $action == "common" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_common_usage
    else
      dq_common_command
    fi

  elif [[ $action == "common older-than" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_common_older_than_usage
    else
      dq_common_older_than_command
    fi

  elif [[ $action == "common newer-than" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_common_newer_than_usage
    else
      dq_common_newer_than_command
    fi

  elif [[ $action == "common find-by-ip-address" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_common_find_by_ip_address_usage
    else
      dq_common_find_by_ip_address_command
    fi

  elif [[ $action == "common names-only" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_common_names_only_usage
    else
      dq_common_names_only_command
    fi

  elif [[ $action == "common ip-addresses-only" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_common_ip_addresses_only_usage
    else
      dq_common_ip_addresses_only_command
    fi

  elif [[ $action == "common env" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dq_common_env_usage
    else
      dq_common_env_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
